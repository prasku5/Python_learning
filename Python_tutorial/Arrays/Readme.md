<h1>Arrays</h1>

Author: Prasanna Kumar 

| **Method**              | **Explanation**                                                                                              | **Parameters**                                | **Example Code**                                                                                                                                                             |
|-------------------------|--------------------------------------------------------------------------------------------------------------|-----------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `append()`              | Adds an element to the end of the list.                                                                       | `element` — The item to be added at the end.   | `lst = [1, 2, 3]`<br>`lst.append(4)`<br>Result: `[1, 2, 3, 4]`                                                                                                           |
| `extend()`              | Adds elements of an iterable to the end of the list.                                                          | `iterable` — An iterable (list, set, etc.).    | `lst = [1, 2, 3]`<br>`lst.extend([4, 5])`<br>Result: `[1, 2, 3, 4, 5]`                                                                                                    |
| `insert()`              | Inserts an element at a specified index.                                                                       | `index, element` — Index where the item is inserted and the item itself. | `lst = [1, 2, 4]`<br>`lst.insert(2, 3)`<br>Result: `[1, 2, 3, 4]`                                                                                                        |
| `remove()`              | Removes the first occurrence of an element from the list.                                                     | `element` — The item to remove.               | `lst = [1, 2, 3, 2]`<br>`lst.remove(2)`<br>Result: `[1, 3, 2]`                                                                                                           |
| `pop()`                 | Removes and returns the item at the specified index (default is the last element).                            | `index` (optional) — Index to remove the item from. | `lst = [1, 2, 3]`<br>`x = lst.pop(1)`<br>Result: `x = 2`, `lst = [1, 3]`                                                                                                 |
| `index()`               | Returns the index of the first occurrence of an element in the list.                                           | `element, start, end` (optional) — The value to search and optional slice bounds. | `lst = [1, 2, 3, 2]`<br>`index = lst.index(2)`<br>Result: `index = 1`                                                                                                     |
| `count()`               | Returns the number of occurrences of an element in the list.                                                   | `element` — The item to count.                | `lst = [1, 2, 3, 2]`<br>`count = lst.count(2)`<br>Result: `count = 2`                                                                                                     |
| `sort()`                | Sorts the list in ascending order (or descending if specified).                                               | `key, reverse` (optional) — Custom sorting function or reverse flag. | `lst = [3, 1, 2]`<br>`lst.sort()`<br>Result: `[1, 2, 3]`<br>`lst.sort(reverse=True)`<br>Result: `[3, 2, 1]`                                                              |
| `reverse()`             | Reverses the order of elements in the list in-place.                                                           | No parameters.                               | `lst = [1, 2, 3]`<br>`lst.reverse()`<br>Result: `[3, 2, 1]`                                                                                                              |
| `copy()`                | Returns a shallow copy of the list.                                                                            | No parameters.                               | `lst = [1, 2, 3]`<br>`copy_lst = lst.copy()`<br>Result: `copy_lst = [1, 2, 3]`                                                                                             |
| `clear()`               | Removes all elements from the list.                                                                            | No parameters.                               | `lst = [1, 2, 3]`<br>`lst.clear()`<br>Result: `lst = []`                                                                                                                 |
| `min()`                 | Returns the smallest element in the list.                                                                      | No parameters.                               | `lst = [3, 1, 2]`<br>`min_elem = min(lst)`<br>Result: `min_elem = 1`                                                                                                      |
| `max()`                 | Returns the largest element in the list.                                                                       | No parameters.                               | `lst = [3, 1, 2]`<br>`max_elem = max(lst)`<br>Result: `max_elem = 3`                                                                                                      |
| `sum()`                 | Returns the sum of all elements in the list (works only for numerical lists).                                 | `start` (optional) — The initial value to start summing from. | `lst = [1, 2, 3]`<br>`sum_val = sum(lst)`<br>Result: `sum_val = 6`<br>`sum_val = sum(lst, 10)`<br>Result: `sum_val = 16`                                                  |
| `slice()`               | Used to get a sublist from the list (Not a method, but a feature of Python lists).                            | `start, stop, step` — Defines the slice bounds and step. | `lst = [1, 2, 3, 4, 5]`<br>`sub_lst = lst[1:4]`<br>Result: `sub_lst = [2, 3, 4]`<br>`sub_lst = lst[::2]`<br>Result: `sub_lst = [1, 3, 5]`                             |
| `list()`                | Converts an iterable into a list.                                                                             | `iterable` — The iterable to convert.         | `iterable = (1, 2, 3)`<br>`lst = list(iterable)`<br>Result: `lst = [1, 2, 3]`                                                                                             |
| `any()`                 | Returns `True` if any element in the list is `True`.                                                           | No parameters.                               | `lst = [0, 1, 2]`<br>`result = any(lst)`<br>Result: `result = True`                                                                                                      |
| `all()`                 | Returns `True` if all elements in the list are `True`.                                                         | No parameters.                               | `lst = [1, 2, 3]`<br>`result = all(lst)`<br>Result: `result = True`<br>`lst = [0, 2, 3]`<br>`result = all(lst)`<br>Result: `result = False` |
| `zip()`                 | Combines multiple iterables into one, element by element.                                                      | `iterable1, iterable2, ...` — Multiple iterables to combine. | `lst1 = [1, 2, 3]`<br>`lst2 = ['a', 'b', 'c']`<br>`zipped = list(zip(lst1, lst2))`<br>Result: `zipped = [(1, 'a'), (2, 'b'), (3, 'c')]`                                     |

## Techniques and Tips for Solving Python Array Problems

| Technique/Tip                        | Description                                                                                         | Example/Usage                                      |
|--------------------------------------|-----------------------------------------------------------------------------------------------------|---------------------------------------------------|
| **1. Understand the Problem First**  | Read the problem carefully and identify the input and desired output. Plan your approach.           | Break down the problem into smaller steps.         |
| **2. Choose the Right Data Structure** | Ensure you are using the right data structure for the task (list, tuple, set, etc.).                 | Use `set` for fast lookups, `list` for ordered collection. |
| **3. Use List Comprehensions**       | Use list comprehensions for clean, concise code when transforming or filtering lists.                | `[x**2 for x in range(10)]`                        |
| **4. Use Built-in Functions**        | Leverage Python’s built-in array functions (`append()`, `pop()`, `sort()`, etc.) for efficiency.      | `my_list.append(5)`, `my_list.sort()`              |
| **5. Handle Edge Cases**             | Account for edge cases such as empty lists or out-of-bound indices before performing operations.     | `if my_list:` to check for an empty list.          |
| **6. Avoid Modifying Lists While Iterating** | Modifying a list while iterating can cause unexpected behavior. Use a copy or index-based iteration. | `for item in my_list.copy():` or `for i in range(len(my_list)):` |
| **7. Use Two Pointers/Sliding Window** | Use the two-pointer or sliding window technique for problems like subarray sums, pairs, etc.          | Iterate with two pointers to find a pair of elements that sum to a target. |
| **8. Apply Binary Search**           | Use binary search for problems involving sorted arrays to improve performance (O(log n) time).       | Use `bisect_left()` from the `bisect` module for binary search. |
| **9. Optimize for Space Complexity** | If memory is a concern, try to solve the problem in-place without creating additional copies of lists. | `my_list.sort()` to sort in-place.                 |
| **10. Use Dictionary for Fast Lookup** | When checking for existence or counting items, use dictionaries or sets to reduce lookup time (O(1)). | `my_dict[element] = my_dict.get(element, 0) + 1`  |
| **11. Practice Divide and Conquer**  | For more complex problems, break them into smaller subproblems (like merge sort or quicksort).        | Use merge sort or quicksort to efficiently sort large lists. |
| **12. Avoid Nested Loops When Possible** | Try to reduce nested loops to improve time complexity, especially in problems involving large lists.   | Use dictionary or set operations to avoid O(n^2) solutions. |
| **13. Use Python's `zip()` Function** | Use `zip()` to combine lists element-wise for problems that require pairing elements from two or more lists. | `for a, b in zip(list1, list2):` |
| **14. Use List Slicing**             | For problems that require subsets of lists, use slicing for simplicity and readability.             | `my_list[start:end]` to get a sublist from index `start` to `end`. |
| **15. Practice Recursion for Complex Problems** | Use recursion for problems that involve breaking down tasks repeatedly, like tree or graph traversal. | Use recursion for depth-first search (DFS) in trees/graphs. |
| **16. Avoid Unnecessary Sorting**    | Only sort a list when it’s required by the problem to avoid extra time complexity.                   | Only sort if necessary, such as in problems where order is important. |
| **17. Use itertools for Combinatorial Problems** | For problems involving combinations, permutations, or product, use `itertools`.                     | `import itertools; itertools.permutations(my_list)` |
| **18. Test with Multiple Inputs**    | Test your solution with a variety of test cases (edge cases, large input) to ensure correctness.      | Test with an empty list, single element list, and large list sizes. |
| **19. Consider Time Complexity**     | Always aim for solutions that are optimal in terms of time complexity, especially for large inputs.   | Choose an O(n) solution over O(n^2) when possible. |

## Key Learnings & Do's

| Learning/Do's                       | Description                                                                                     | Example                                      |
|-------------------------------------|-------------------------------------------------------------------------------------------------|----------------------------------------------|
| **1. Use Lists Wisely**             | Lists are dynamic and versatile. Use them for collections of items that need to be modified frequently. | `my_list = [1, 2, 3]; my_list.append(4)`     |
| **2. Avoid Unnecessary Complexity** | Don't overcomplicate code with unnecessary loops or list comprehensions.                         | Don't: `[x for x in range(10) if x % 2 == 0]`; Do: `list(range(0, 10, 2))` |
| **3. Iterate Correctly**            | Use `for item in list:` instead of `for i in range(len(list)):` unless you need the index.        | Don't: `for i in range(len(my_list)):`; Do: `for item in my_list:` |
| **4. Handle Index Errors**          | Always ensure the index exists before accessing it.                                               | `if i < len(my_list): my_list[i] = value`    |
| **5. Use Built-in Functions**       | Leverage built-in functions like `append()`, `extend()`, `sort()`, and `reverse()`.               | `my_list.sort()` or `my_list.reverse()`      |
| **6. Avoid Mutable Default Arguments** | Be cautious with mutable default arguments in functions.                                         | Don't: `def func(my_list=[]):`; Do: `def func(my_list=None): if my_list is None: my_list = []` |
| **7. Use List Comprehensions Judiciously** | List comprehensions are powerful but can reduce readability if overused.                         | Do: `[x**2 for x in range(10)]` for simple transformations. |
| **8. Follow PEP8 Guidelines**       | Consistently follow Python's style guide for better readability.                                 | Use spaces around operators, e.g., `x = 5` instead of `x=5`. |
| **9. Test Thoroughly**              | Always write tests for your code to catch unexpected behavior.                                    | Use `unittest` module to write unit tests.    |
| **10. Use Efficient Data Structures** | Choose the right data structure for the problem. For example, use `set` for fast membership testing. | `my_set = set([1, 2, 3])` for fast lookups.  |
| **11. Avoid Catching All Exceptions** | Avoid bare `except:` clauses; instead, catch specific exceptions.                                | Don't: `try: ... except:`; Do: `try: ... except ValueError:` |
| **12. Use Type Hints**              | Use type hints to improve code readability and facilitate static type checking.                   | `def greet(name: str) -> None:`               |
| **13. Learn Common Libraries**      | Familiarize yourself with libraries like `numpy` for numerical operations.                       | `import numpy as np; np.array([1, 2, 3])`    |
| **14. Practice with Real-World Problems** | Apply Python skills to real-world problems or projects to deepen understanding.                   | Participate in coding challenges or contribute to open-source projects. |

## Common Mistakes

| Mistake                             | Description                                                                                     | Example                                      |
|-------------------------------------|-------------------------------------------------------------------------------------------------|----------------------------------------------|
| **1. Index Out of Range**           | Accessing an index that does not exist.                                                           | `my_list = [1, 2]; print(my_list[2])`        |
| **2. Mutable Default Argument**     | Using mutable objects as default arguments can lead to unexpected behavior.                       | `def append_to_list(element, list=[]): list.append(element)` |
| **3. Incorrect Looping**            | Using `range(len(list))` when not necessary.                                                      | Don't: `for i in range(len(my_list)):`; Do: `for item in my_list:` |
| **4. Overusing List Comprehensions** | Reducing readability by using list comprehensions for complex operations.                         | Avoid complex logic within list comprehensions. |
| **5. Not Following PEP8**           | Ignoring Python's official style guide can make code harder to read.                              | Use consistent spacing and naming conventions. |
